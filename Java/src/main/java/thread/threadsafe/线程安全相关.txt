可重入锁：
    一个线程中的多个流程可以获取同一把锁，持有这把同步锁可以再次进入；ReentrantLock 和 synchronized 都是可重入锁

可中断锁：
    可中断锁是子线程再获取锁的过程中，是否是可以响应线程中断操作。
    synchronized 是不可中断锁，ReentrantLock是可中断的
    对于synchronized关键字，如果一个线程在等待获取锁，最终只有2中结果
        1、要么获取到锁然后继续后面的操作
        2、要么一致等待，直到其他线程释放锁为止
    而ReentrantLock是可中断的（发起获取锁请求到还未获取到锁这段时间内是可以被中断的）
        可中断的条件：1、使用lock.lockInterruptibly() 方法获取锁 2、在为了拿到锁而等待的过程中调用该线程的 interrupt 方法
        1、ReentrankLokc中必须使用实例方法 lockInterruptibly() 获取锁时，在线程调用 interrupt() 方法之后才会引发 InterruptedException 异常，中断该获取锁等待的动作
        2、线程调用interrupt()之后，线程的中断标志会被置为true
        3、触发InterruptedException一场之后，线程的中断标志会被清空，级置为false
        4、所以当线程调用interrupt()引发InterruptedException异常，中断标志的变化是: false -> true -> false

公平锁和非公平锁：
    公平锁是指多个线程尝试获取同一把锁的时候，获取锁的顺序按照线程到达的先后顺序获取，而不是随机插队的方式获取。
    synchronized是非公平锁，ReentrantLock是两种都可以实现，不过默认是非公平锁


乐观锁和悲观锁
    乐观锁认为自己在使用数据时不会有别的线程修改数据，所以就不会添加锁，只是在更新数据的时候去判断之前有没有别的线程更新了这个数据。
    如果这个数据没有被更新，当前线程将自己修改的数据成功写入。如果数据已经被其他线程更新，则根据不同的实现方式执行不同的操作。
    乐观锁在java中是通过无锁编程来实现，最常采用的CAS算法，java原子类中的递增操作就是通过CAS自旋实现的。
    适合读操作多的场景，不加锁的特点能够使其读操作的性能大幅提升。

    悲观锁认为自己在使用数据的时候一定有别的线程来修改数据，因此在获取数据的时候会先加锁，确保数据不会被别的线程修改。
    synchronized关键字和Lock实现类都是悲观锁。
    适合写操作多的场景，先加锁可以确保写操作时数据正确。
    显示的锁定之后在操作同步资源。

共享锁和排他锁
    排他锁又称独占锁，获得了以后既能读又能写，其他没有获得锁的线程不能读也不能写，典型的synchronized就是排他锁
    共享锁又称读锁，获得了共享锁以后可以查看但无法修改和删除数据，其他线程也能获得共享锁，也可以查看但不能修改和删除数据
读写锁规则
    多个线程只申请读锁，都能申请到
    如果有一个线程已经占用了读锁，则此时其他线程如果要申请写锁，则申请写锁的线程会一直等待释放该锁
    如果有一个线程已经占用写锁，则其他线程申请写锁或读锁都要等待它释放

wait/sleep的区别？
    1、所属类不同：sleep是线程中的方法，但是wait是Object中的方法
    2、语法不同：sleep不依赖于同步器synchronized，但是wait需要依赖synchronized关键字
    3、参数不同：sleep必须设置参数时间，wait可以不设置事件，不设置将一直休眠，直到被唤醒
    4、释放锁资源不同：sleep方法不会释放lock，但是wait会释放，而且会加到等待队列中
    5、唤醒方式不同：sleep不需要被唤醒（休眠之后退出阻塞），但是wait需要（不指定时间需要被别人中断）
    6、线程进入状态不同：调用sleep方法线程会进入TIMED_WAITING有限等待状态，而调用无参数的wait方法，线程会进入WAITING无显示等待状态

synchronized和lock的区别
    1、首先synchronized时java内置关键字，在jvm层面，Lock是一个java类
    2、synchronized无法判断是否获取所得状态，Lock可以判断是否获取到锁
    3、synchronized会自动释放锁(a线程执行完同步代码会释放锁；b线程执行过程中发生异常会释放锁)，Lock需要在finally中手动释放锁(unlock()释放锁)，否则容易造成死锁
    4、使用synchronized关键字的两个线程1和2，如果当前线程1获得锁，线程2则进入等待。如果线程1阻塞，则线程2一直等待下去，Lock锁可以使用(lock.lockInterruptibly() 后续调用该线程的interrupt()方法中断等待) 决定在等待一段时间后不再等待直接进入中断异常，结束等待
    5、synchronized锁可重入、不可中断、非公平 Lock可重入、可中断、可公平（两者皆可）
    6、Lock锁适合大量同步的代码的同步问题，synchronized锁适合代码少量的同步问题