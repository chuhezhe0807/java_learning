锁升级的过程：
    new -> 偏向锁 -> 轻量级锁（无锁、自旋锁、自适应自旋） -> 重量级锁

锁的几种状态
    无状态(001) --(偏向锁启用 一个线程加锁，将线程id写入对象头中的markword)--> 偏向锁(101)
        --(已经有偏向锁了，其他线程线程加锁，则升级为轻量级锁)--> 轻量级锁(00)
            --(CAS自旋不成功【锁膨胀】 重度竞争)--> 重量级锁(10)

    偏向锁未启用 跳过偏向锁 直接由无状态变为轻量级锁

    偏向锁 --(调用wait方法，这个时重量级锁monitor才有的实现)--> 重量级锁

    偏向锁 --(如果加锁对象已经有了线程id并且有其他线程争抢，立刻升级成为轻量级锁)--> 轻量级锁

    如果某一类锁对象的总撤销数超过了一个阈值（对应 Java 虚拟机参数 -XX:BiasedLockingBulkRebiasThreshold，默认为 20），
        那么 Java 虚拟机会宣布这个类的偏向锁失效。
    如果总撤销数超过另一个阈值（对应 Java 虚拟机参数 -XX:BiasedLockingBulkRevokeThreshold，默认值为 40），
        那么 Java 虚拟机会认为这个类已经不再适合偏向锁。此时，Java 虚拟机会撤销该类实例的偏向锁，并且在之后的加锁过程中直接为该类实例设置轻量级锁。

    进行加锁操作时，Java 虚拟机会判断是否已经是重量级锁。如果不是，它会在当前线程的当前栈桢中划出一块空间，作为该锁的锁记录，
        并且将锁对象的标记字段 复制到该锁记录中。然后，Java 虚拟机会尝试用 CAS（compare-and-swap）操作替换锁对象的标记字段。
            Java 锁标志位是不是01偏向锁。如果是，则替换为刚才分配的锁记录的地址，升级为00轻量级锁。此时，该线程已成功获得这把锁，可以继续执行了。
            如果不是 01偏向锁，那么有两种可能。
                第一，该线程重复获取同一把锁（此刻持有的是轻量级锁）。此时，Java 虚拟机会将锁记录清零，以代表该锁被重复获取。
                第二，其他线程持有该锁（此刻持有的是轻量级锁）。此时，Java 虚拟机会将这把锁膨胀为重量级锁，并且阻塞当前线程。


为什么要有偏向锁？
    因为使用了 synchronized 包裹的代码块可能出现多个线程争抢一个资源的情况比较少，造成加锁的一系列操作的浪费
    偏向锁就是把当前线程的id放在加锁对象的内部暂存，释放锁后，下一次加锁的时候只需要判断加锁对象的内部存的线程id和当前线程id是否一致，
        如果一致则直接让该线程获取加锁对象的锁，不需要加申请锁的其他的逻辑
        如果不一致则通过CAS操作将加锁对象的markword中的线程id改为当前线程的id，加锁对象的总撤销偏向锁数超过了一个阈值
            （对应 Java 虚拟机参数 -XX:BiasedLockingBulkRebiasThreshold，默认为 20），那么 Java 虚拟机会宣布这个类的偏向锁失效，则升级称为轻量级锁


CAS: compareAndSet
    在修改一个值的时候会先进行判断，看看要修改这个值的这一时刻，这个值与oldValue变了没有(这个值可能已经被其他线程修改过了)
        如果一样则将修改后的赋值给oldValue，此次修改成功
        如果不一样将这个值视为oldValue，然后继续自旋操作

cas也叫
    无锁(代码层面没有锁，硬件层面有锁)
    自旋锁
    乐观锁
    轻量级锁

cas中的原子性问题：在 compareAndSet 的过程中，compare 和 set 操作之间也可能有其他线程来设置值
    硬件层面(Intel x86架构)使用 lock 和 cmpxchgg 两条指令解决，也是加了一把锁，可以认为是一个原子操作

cas中的ABA问题：在自旋查看当前值与oldValue是否相等时，可能有一个线程将值由A改为B，又改为A，导致自旋时认为之没有改变
    设置值的时候可以加一个version 版本号（版本号自增），对比值的时候同时对比版本号